# 設計模式
總共 23 種，通常是為了要處理專案的可維護性，或者性能瓶頸才會用設計模式去解決部分的問題

#### 創建型模式
創建型模式主要關注於對象創建的過程，它們提供了實例化對象的各種方式，使系統對實例化過程的依賴減到最小。

###### 單例模式（Singleton）
概述：確保一個類只有一個實例，並提供一個全局訪問點。
適用情境：當需要確保全局使用同一資源或配置時，如數據庫連接或系統設置。

###### 工廠方法模式（Factory Method）
概述：定義一個創建對象的接口，但讓子類決定要實例化的類。工廠方法讓類的實例化延遲到子類進行。
適用情境：當一個類不能預測它需要創建哪些類的對象時。

###### 抽象工廠模式（Abstract Factory）
概述：提供一個接口，用於創建相關或依賴對象的家族，而不需要明確指定具體類。
適用情境：當系統需要獨立於如何創造、組合和表示產品時。

###### 建造者模式（Builder）
概述：將一個複雜對象的構建與它的表示分離，使得同樣的構建過程可以創建不同的表示。
適用情境：當創建複雜對象的算法應獨立於該對象的組件以及它們的裝配方式時。

###### 原型模式（Prototype）
概述：用原型實例指定創建對象的種類，並通過拷貝這些原型創建新的對象。
適用情境：當一個系統應該獨立於它的產品創建、組合或表示時；當要實例化的類是在運行時刻指定時，例如，通過動態加載。


#### 結構型模式
結構型模式關注於如何組織和組合類和對象來形成更大的結構，以及如何通過這些結構來提高系統的靈活性和效率。

###### 適配器模式（Adapter）
概述：允許將一個類的接口轉換成客戶期望的另一個接口。適配器模式讓那些接口不兼容的類可以一起工作。
適用情境：當希望使用一些現有的類，但其接口不符合你的需求時。

###### 橋接模式（Bridge）
概述：將抽象部分與其實現部分分離，使它們都可以獨立地變化。
適用情境：當希望避免抽象和其實現之間的永久綁定時；當抽象和實現都應該通過生成子類來擴展時。

###### 裝飾模式（Decorator）
概述：動態地給一個對象添加一些額外的職責。就增加功能來說，裝飾者模式相比生成子類更為靈活。
適用情境：當系統需要新功能時，為避免使用大量子類來擴展對象功能，或當對象的功能應該在運行時動態添加或刪除時。

###### 組合模式（Composite）
概述：將對象組合成樹形結構以表示“部分-整體”的層次結構。組合使得用戶對單個對象和組合對象的使用具有一致性。
適用情境：當希望客戶端忽略組合對象與單個對象的差異時。

###### 外觀模式（Facade）
概述：提供了一個統一的接口，用來訪問子系統中的一群接口。外觀定義了一個高層接口，讓子系統更容易使用。
適用情境：當需要一個簡單的接口來訪問一個複雜系統時，或者當客戶端與抽象類的實現部分之間存在很大的依賴性時。

###### 享元模式（Flyweight）
概述：運用共享技術有效地支持大量細粒度的對象。
適用情境：當系統中有大量對象，這些對象消耗大量記憶體時，且對象的狀態大部分可以外部化時。

###### 代理模式（Proxy）
概述：為其他對象提供一種代理以控制對這個對象的訪


#### 行為型模式
主要關注於算法和對象間職責的分配。它們描述了對象或類的結構如何在不同的情境中解決特定問題，以及如何實現算法的變化，從而使系統在運行時能夠更加靈活地決定如何執行任務。以下是行為型模式的概述和適用情境：

###### 模板方法模式（Template Method）
概述：在一個方法中定義一個算法的骨架，而將一些步驟延遲到子類中。模板方法使得子類可以在不改變算法結構的情況下，重新定義算法中的某些步驟。
適用情境：當多個類有相同的方法，但是算法的步驟在這些類之間有所不同時。

###### 命令模式（Command）
概述：將一個請求封裝成一個對象，從而使你可用不同的請求對客戶進行參數化；對請求排隊或記錄請求日誌，以及支持可撤銷的操作。
適用情境：當需要對操作進行記錄、撤銷/重做、事務等處理時。

###### 迭代器模式（Iterator）
概述：提供一種方法順序訪問一個聚合對象中各個元素，而又不暴露該對象的內部表示。
適用情境：當需要訪問一個聚合對象的內容而無需暴露其內部表示時。

###### 觀察者模式（Observer）
概述：定義了一種一對多的依賴關係，讓多個觀察者對象同時監聽某一個主題對象。這個主題對象在狀態發生變化時，會通知所有觀察者對象，使它們能夠自動更新自己。
適用情境：當一個對象的改變需要同時改變其他對象，且它不知道具體有多少對象有待改變時。

###### 中介者模式（Mediator）
概述：用一個中介對象來封裝一系列的對象交互。中介者使各對象不需要顯示地相互參考，從而使其耦合鬆散，而且可以獨立地改變它們之間的交互。
適用情境：當一組對象以定義良好但複雜的方式進行通信時，導致依賴關係結構混亂且難以理解。

###### 備忘錄模式（Memento）
概述：在不破壞封裝的前提下，捕獲一個對象的內部狀態，並在該對象之外保存這個狀態。這樣以後就可將該對象恢復到原先保存的狀態。
適用情境：當需要保存一個對象在某一時刻的狀態，以便在未來某個時刻可以恢復到該狀態時。

###### 解釋器模式（Interpreter）
概述：給定一個語言，定義它的文法的一種表示，並定義一個解釋器，這個解釋器使用該表示來解釋語言中的句子。
適用情境：當有一個語言需要解釋執行，且你可將該語言中的句子表示為一個抽象語法樹時。

###### 狀態模式（State）
概述：允許一個對象在其內部狀態改變時改變它的行為，對象看起來好像修改了它的類。
適用情境：當一個對象的行為取決於它的狀態，且它必須在運行時根據狀態改變它的行為時。

###### 策略模式（Strategy）
概述：定義一系列的算法，把它們一個個封裝起來，並使它們可相互替換。本模式使得算法可獨立於使用它的客戶端而變化。
適用情境：當有多種類似的類，而且它們之間僅在於它們的行為不同時。

###### 責任鏈模式（Chain of Responsibility）
概述：為請求創建一個接收者對象的鏈。這種模式給予請求的類型，對請求的發送者和接收者進行解耦。
適用情境：當需要讓多個對象有機會處理某個請求時，從而避免請求的發送者和接收者之間的耦合關係。將這些對象連成一條鏈，並沿著這條鏈傳遞該請求，直到有一個對象處理它為止。

###### 訪問者模式（Visitor）
概述：表示一個作用於某對象結構中的各元素的操作。它使你可以在不改變各元素的類的前提下定義作用於這些元素的新操作。
適用情境：當一個對象結構包含很多類對象，它們有不同的接口，而你想對這些對象進行一些依賴於其具體類的操作時。
